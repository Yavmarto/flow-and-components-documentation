---
title: Creating a Component Using Existing Components
order: 4
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]
= Vaadin mixin interfaces

A mixin refers to a defined amount of functionality which can be added to a class.

Before Java 8, interfaces could have only abstract methods.
In Java 8 developers has the possibility to add default methods to interfaces.
Default methods contains

Vaadin has some predifined mixins that allows developers to add functionalities to their components.

Amount the most important mixins are:

* HasSize
* HasComponents
* HasStyle

[NOTE]
There much more elements.

* HasEnabled
* HasElement
* HasDataProvider<T>
* HasValidation
* HasItems
* HasOrderedComponents
* HasText
* Focusable<T>


== HasSize

Any component implementing this interface supports setting the size of the
component using {@link #setWidth(String)} and {@link #setHeight(String)}

* setWidth
* getWidth
* setHeight
* getHeight
* setSizeFull
* setSizeUndefined

== HasStyle

[source,java]
----
public interface HasSize extends HasElement {

    default void setWidth(String width) {
        getElement().getStyle().set(ElementConstants.STYLE_WIDTH, width);
    }

    default String getWidth() {
        return getElement().getStyle().get(ElementConstants.STYLE_WIDTH);
    }

    default void setHeight(String height) {
        getElement().getStyle().set(ElementConstants.STYLE_HEIGHT, height);
    }

    default String getHeight() {
        return getElement().getStyle().get(ElementConstants.STYLE_HEIGHT);
    }

    default void setSizeFull() {
        setWidth("100%");
        setHeight("100%");
    }

    default void setSizeUndefined() {
        setWidth(null);
        setHeight(null);
    }
----

[source,java]
----
public interface HasComponents extends HasElement, HasEnabled {

    default void add(Component... components) {
        Objects.requireNonNull(components, "Components should not be null");
        for (Component component : components) {
            Objects.requireNonNull(component,
                    "Component to add cannot be null");
            getElement().appendChild(component.getElement());
        }
    }

    default void remove(Component... components) {
        Objects.requireNonNull(components, "Components should not be null");
        for (Component component : components) {
            Objects.requireNonNull(component,
                    "Component to remove cannot be null");
            Element parent = component.getElement().getParent();
            if (parent == null) {
                LoggerFactory.getLogger(HasComponents.class).debug(
                        "Remove of a component with no parent does nothing.");
                return;
            }
            if (getElement().equals(parent)) {
                getElement().removeChild(component.getElement());
            } else {
                throw new IllegalArgumentException("The given component ("
                        + component + ") is not a child of this component");
            }
        }
    }

    default void removeAll() {
        getElement().removeAllChildren();
    }
}
----

Implementation

[source,java]
----
public class Tooltip extends Component implements HasComponents, HasStyle {

}
----

[source,html]
----
<dom-module id="incubator-tooltip">
  <template>
    <div part="content" theme="dark">
      <slot></slot>
    </div>
  </template>
</dom-module>
----

[NOTE]
The component that implements HasComponents needs to have an `slot`.

Just adding the interface it will add components to it:

[source,java]
----
Tooltip tooltip = new Tooltip();

tooltip.add(new H5("Tooltip"));
tooltip.add(new Paragraph("I am a paragraph"));
----


== Why is it recommended to use them?

With out those mixins it would be necessary to

Developers who use the component will save time:

`setWidth("300px)` vs `getElement().getStyle().set("width", "300px")`.

It provides and standard api to all components:

* verticalLayout.add(Components)
* horizontalLayout.add(Components)
* tabs.add(Components)

[TIP]
Do not reinvent the wheel.